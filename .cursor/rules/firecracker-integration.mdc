---
description: 
globs: 
alwaysApply: false
---
# Firecracker Integration Rules

## Performance First Philosophy

Every piece of Firecracker integration code must be **performance-optimized**:

- Boot time target: **< 100ms** from API call to ready
- Command execution: **< 10ms** overhead vs bare metal
- Memory usage: **< 50MB** for basic workloads
- Use our `pkg/testing/tstream` tools to identify bottlenecks

## Init Injection Advantage

Leverage our **SSH-free command execution** system:

```go
// Instead of SSH overhead, use our embedded init system
// Located in pkg/bootloader/linux.go - PrepareInitramfsCpio
// This gives us a massive performance advantage over standard Firecracker
```

## API Compatibility

Maintain **100% Firecracker REST API compatibility**:

- Use `gen/firecracker-swagger-go/` for API definitions
- All endpoints must respond with identical JSON structures
- Performance enhancements are internal - API stays compatible
- Test against real Firecracker integration tests

## Apple VZ Integration

Build on our existing Apple Virtualization Framework:

```go
// sandbox/pkg/cloud/hypervisor/applevf/
// This is already working - focus on Firecracker API layer
// Don't reinvent the VM management - enhance it
```

## Error Handling

Use our standard error patterns:

```go
import "gitlab.com/tozd/go/errors"

// Always use errors.Errorf with descriptive action names
return errors.Errorf("starting firecracker VM: %w", err)
```

## Logging and Context

All Firecracker operations must be observable:

```go
import "github.com/rs/zerolog"

func StartVM(ctx context.Context, config *Config) error {
    log := zerolog.Ctx(ctx)
    log.Info().Str("vm_id", config.ID).Msg("starting firecracker VM")
    
    // Use context everywhere for cancellation and tracing
}
```

## Testing Requirements

- **Function coverage > 85%** for all Firecracker integration code
- Use `./gow test -function-coverage` to verify
- Performance benchmarks for critical paths
- Integration tests with real Firecracker API consumers

## Code Organization

```
sandbox/pkg/cloud/hypervisor/
â”œâ”€â”€ applevf/           # Apple VZ integration (existing)
â”œâ”€â”€ firecracker/       # Firecracker API compatibility layer (your focus)
â”‚   â”œâ”€â”€ api/          # REST API handlers
â”‚   â”œâ”€â”€ vm/           # VM lifecycle management  
â”‚   â”œâ”€â”€ config/       # Configuration management
â”‚   â””â”€â”€ performance/  # Performance optimization
```

## Performance Monitoring

Integrate with our stream performance tools:

```go
import "github.com/walteh/ec1/pkg/testing/tstream"

// Wrap critical operations with timing
reader := tstream.NewTimingReader(vmConfigReader)
// Automatic bottleneck detection and reporting
```

## Firecracker-Specific Patterns

### VM Lifecycle
- Use Apple VZ for actual virtualization
- Firecracker API provides the interface
- Init injection handles command execution
- gRPC for high-performance guest communication

### Configuration Management  
- Parse Firecracker JSON configs
- Convert to Apple VZ parameters
- Validate resource constraints
- Apply security policies

### Boot Optimization
- Leverage our init injection for faster startup
- Skip unnecessary Firecracker initialization steps
- Use Apple VZ native features where possible
- Profile boot sequence with our tools

## Never Do This

- Don't bypass our performance testing tools
- Don't reinvent VM management (use Apple VZ layer)
- Don't break Firecracker API compatibility
- Don't add SSH dependencies (we have init injection!)
- Don't ignore the 85% test coverage requirement

## Performance Debugging

When things are slow, use our tools:

```bash
# Profile a specific operation
./gow test -run BenchmarkFirecrackerBoot -cpuprofile=cpu.prof

# Check stream performance
./gow test -run TestFirecrackerStreamPerformance

# Function coverage analysis
./gow test -function-coverage ./sandbox/pkg/cloud/hypervisor/firecracker/
```

## Integration with Existing Code

The bootloader system is your secret weapon:

```go
// pkg/bootloader/linux.go - This eliminates SSH overhead
bootloaderConfig := &bootloader.Config{
    InitInjection: true,  // Our performance advantage!
    CustomInit:    "/path/to/our/grpc/init",
}
```

## Success Metrics

Your Firecracker integration is successful when:

- âœ… Boot time < 100ms (measured end-to-end)
- âœ… 100% Firecracker API compatibility 
- âœ… Command execution without SSH overhead
- âœ… Function test coverage > 85%
- âœ… Memory usage < 50MB baseline
- âœ… Integration tests pass with real consumers

Remember: We're not just implementing Firecracker - we're making it **faster than anyone thought possible** with our init injection system! ðŸš€

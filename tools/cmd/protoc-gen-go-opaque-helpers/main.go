package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet
	enableProtovalidate := flags.Bool("enable_protovalidate", false, "generate protovalidate helpers")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL | pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		gen.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_2023
		gen.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2024

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			if err := generateFile(gen, f, *enableProtovalidate); err != nil {
				return fmt.Errorf("failed to generate file %s: %w", f.Desc.Path(), err)
			}
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File, enableValidation bool) error {
	if len(file.Messages) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_opaque_helpers.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateFileHeader(g, file)

	var hasValidationHelpers bool
	
	// Process all messages recursively (including nested ones)
	var processMessages func([]*protogen.Message)
	processMessages = func(messages []*protogen.Message) {
		for _, message := range messages {
			if shouldGenerateHelpers(message) {
				generateMessageHelpers(g, message, enableValidation)
				if enableValidation {
					hasValidationHelpers = true
				}
			}
			// Recursively process nested messages
			processMessages(message.Messages)
		}
	}
	
	processMessages(file.Messages)

	if hasValidationHelpers {
		g.QualifiedGoIdent(protogen.GoIdent{
			GoName:       "Validate",
			GoImportPath: "buf.build/go/protovalidate",
		})
	}

	return nil
}

func generateFileHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-go-opaque-helpers. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate ptr helper function
	g.P("// ptr is a helper function to get a pointer to a value")
	g.P("func ptr[T any](v T) *T { return &v }")
	g.P()
}

func shouldGenerateHelpers(message *protogen.Message) bool {
	// Skip nested types (map entries, oneof wrappers)
	if message.Desc.IsMapEntry() {
		return false
	}
	
	// Skip messages that are oneofs (ending with underscore)
	if strings.HasSuffix(string(message.Desc.Name()), "_") {
		return false
	}
	
	// Generate helpers for both top-level messages and nested messages
	// (like ExecRequest_Start, ExecResponse_Exit, etc.)
	// In edition 2023/2024 with opaque API, all non-map, non-oneof messages have builders
	return true
}

func generateMessageHelpers(g *protogen.GeneratedFile, message *protogen.Message, enableValidation bool) {
	messageName := message.GoIdent.GoName
	builderName := messageName + "_builder"

	// Generate New helper
	g.P("// New", messageName, " creates a new ", messageName, " using the builder pattern")
	g.P("func New", messageName, "(f func(*", builderName, ")) *", messageName, " {")
	g.P("	b := &", builderName, "{}")
	g.P("	f(b)")
	g.P("	return b.Build()")
	g.P("}")
	g.P()

	if enableValidation {
		validateIdent := g.QualifiedGoIdent(protogen.GoIdent{
			GoName:       "Validate",
			GoImportPath: "buf.build/go/protovalidate",
		})

		// Generate NewValidated helper
		g.P("// NewValidated", messageName, " creates a new ", messageName, " using the builder pattern with validation")
		g.P("func NewValidated", messageName, "(f func(*", builderName, ")) (*", messageName, ", error) {")
		g.P("	m := New", messageName, "(f)")
		g.P("	if err := ", validateIdent, "(m); err != nil {")
		g.P("		return nil, err")
		g.P("	}")
		g.P("	return m, nil")
		g.P("}")
		g.P()
	}
}

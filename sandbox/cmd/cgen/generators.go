package main

import (
	"fmt"
	"strings"
)

// generateMethodShim creates C shim code for Swift methods
func generateMethodShim(root Root) string {
	// Extract module name for imports
	moduleName := root.Module.Name

	// Start with header
	result := fmt.Sprintf(`#import <Foundation/Foundation.h>
#import <objc/message.h>
#import <objc/runtime.h>
#import <%s/%s.h>

#ifdef __cplusplus
extern "C" {
#endif

`, moduleName, moduleName)

	// Process all method symbols
	for _, symbol := range root.Symbols {
		// if isSwiftSymbol(symbol.Identifier.Precise) {
		// 	continue
		// }
		if isCompletion(symbol.FunctionSignature) {
			continue
		}
		if symbol.Kind.Identifier == "swift.method" {
			result += processMethod(symbol)
		} else if symbol.Kind.Identifier == "swift.var" || symbol.Kind.Identifier == "swift.property" {
			result += processVariable(symbol)
		} else if symbol.Kind.Identifier == "swift.struct" ||
			symbol.Kind.Identifier == "swift.class" ||
			symbol.Kind.Identifier == "swift.enum" ||
			symbol.Kind.Identifier == "swift.protocol" {
			// Types are handled by generateGoTypes
		}
	}

	// Add footer
	result += `
#ifdef __cplusplus
}
#endif
`
	return result
}

// Process a method symbol into C shim code
func processMethod(symbol Symbol) string {
	usr := sanitizeUSR(symbol.Identifier.Precise)
	returnType := getReturnType(symbol.FunctionSignature)
	params, args := makeParams(symbol.FunctionSignature)

	// Check if we have enough path components
	if len(symbol.PathComponents) < 2 {
		// Skip this method if we don't have enough path components
		return ""
	}

	methodName := symbol.PathComponents[1]

	// Build the method implementation
	methodImpl := fmt.Sprintf("// Shim for Swift method: %s\n", symbol.Names.Title)
	methodImpl += fmt.Sprintf("%s %s(%s) {\n", returnType, usr, params)
	methodImpl += "    id obj = (__bridge id)self;\n"

	// Add function pointer type for objc_msgSend
	methodImpl += fmt.Sprintf("    typedef %s (*MsgFn)(id, SEL", returnType)
	if len(symbol.FunctionSignature.Parameters) > 0 {
		methodImpl += ", id" + strings.Repeat(", id", len(symbol.FunctionSignature.Parameters))
	}
	methodImpl += ");\n"
	methodImpl += "    MsgFn fn = (MsgFn)objc_msgSend;\n"

	// Call the method
	if len(symbol.FunctionSignature.Parameters) == 0 {
		if returnType == "void*" {
			methodImpl += fmt.Sprintf("    id rv = fn(obj, sel_getUid(\"%s\"));\n", methodName)
			methodImpl += "    return (__bridge_retained void*)rv;\n"
		} else {
			methodImpl += fmt.Sprintf("    fn(obj, sel_getUid(\"%s\"));\n", methodName)
			methodImpl += "    return NULL;\n"
		}
	} else {
		methodImpl += fmt.Sprintf("    id rv = fn(obj,\n")
		methodImpl += fmt.Sprintf("               sel_getUid(\"%s:\"),\n", methodName)
		methodImpl += fmt.Sprintf("               %s);\n", args)
		methodImpl += "    return (__bridge_retained void*)rv;\n"
	}

	methodImpl += "}\n\n"
	return methodImpl
}

// Process a variable or property symbol into C shim code
func processVariable(symbol Symbol) string {
	usr := sanitizeUSR(symbol.Identifier.Precise)

	// Check if we have enough path components
	if len(symbol.PathComponents) < 2 {
		// Skip this variable if we don't have enough path components
		return ""
	}

	propertyName := symbol.PathComponents[1]

	// Build getter function
	getterImpl := fmt.Sprintf("// Shim for Swift property getter: %s\n", symbol.Names.Title)
	getterImpl += fmt.Sprintf("void* %s_get(void* self) {\n", usr)
	getterImpl += "    id obj = (__bridge id)self;\n"
	getterImpl += "    typedef id (*MsgFn)(id, SEL);\n"
	getterImpl += "    MsgFn fn = (MsgFn)objc_msgSend;\n"
	getterImpl += fmt.Sprintf("    id rv = fn(obj, sel_getUid(\"%s\"));\n", propertyName)
	getterImpl += "    return (__bridge_retained void*)rv;\n"
	getterImpl += "}\n\n"

	// Build setter function if property is not readonly
	// Note: This is a simplification - we would need to check if property is writable
	setterImpl := fmt.Sprintf("// Shim for Swift property setter: %s\n", symbol.Names.Title)
	setterImpl += fmt.Sprintf("void %s_set(void* self, void* value) {\n", usr)
	setterImpl += "    id obj = (__bridge id)self;\n"
	setterImpl += "    id val = (__bridge id)value;\n"
	setterImpl += "    typedef void (*MsgFn)(id, SEL, id);\n"
	setterImpl += "    MsgFn fn = (MsgFn)objc_msgSend;\n"
	setterImpl += fmt.Sprintf("    fn(obj, sel_getUid(\"set%s:\"), val);\n", capitalizeFirst(propertyName))
	setterImpl += "}\n\n"

	return getterImpl + setterImpl
}

// Generate Go type definitions from Swift types
func generateGoTypes(root Root) string {
	packageName := strings.ToLower(root.Module.Name)

	result := fmt.Sprintf(`// Code generated by cgen; DO NOT EDIT.
package %s

import (
	"unsafe"
)

// #cgo CFLAGS: -x objective-c
// #cgo LDFLAGS: -framework %s
// #include <%s/%s.h>
// #include "%s.shim.h"
import "C"

`, packageName, root.Module.Name, root.Module.Name, root.Module.Name, root.Module.Name)

	// Process all type symbols
	typeMap := make(map[string]bool)
	for _, symbol := range root.Symbols {
		if symbol.Kind.Identifier == "swift.struct" ||
			symbol.Kind.Identifier == "swift.class" ||
			symbol.Kind.Identifier == "swift.enum" ||
			symbol.Kind.Identifier == "swift.protocol" {

			typeName := symbol.Names.Title
			if typeMap[typeName] {
				continue // Skip duplicates
			}
			typeMap[typeName] = true

			result += processGoType(symbol)
		}
	}

	return result
}

// Process a type symbol into Go type definition with methods
func processGoType(symbol Symbol) string {
	typeName := symbol.Names.Title

	// Start with type definition
	typeImpl := fmt.Sprintf("// %s represents a Swift %s\n", typeName, symbol.Kind.Identifier[6:])
	typeImpl += fmt.Sprintf("type %s struct {\n", typeName)
	typeImpl += "    ptr unsafe.Pointer\n"
	typeImpl += "}\n\n"

	// TODO: Add factory methods and instance methods for this type
	// We would need to filter the symbols to find methods related to this type

	return typeImpl
}

// Helper function to capitalize the first letter of a string
func capitalizeFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

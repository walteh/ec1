// Code generated by mockery. DO NOT EDIT.

package mockvmm

import (
	context "context"

	archives "github.com/mholt/archives"

	io "io"

	mock "github.com/stretchr/testify/mock"

	vmm "github.com/walteh/ec1/pkg/vmm"
)

// MockHypervisor is an autogenerated mock type for the Hypervisor type
type MockHypervisor[VM vmm.VirtualMachine] struct {
	mock.Mock
}

type MockHypervisor_Expecter[VM vmm.VirtualMachine] struct {
	mock *mock.Mock
}

func (_m *MockHypervisor[VM]) EXPECT() *MockHypervisor_Expecter[VM] {
	return &MockHypervisor_Expecter[VM]{mock: &_m.Mock}
}

// EncodeLinuxInitramfs provides a mock function with given fields: ctx, initramfs
func (_m *MockHypervisor[VM]) EncodeLinuxInitramfs(ctx context.Context, initramfs io.Reader) (io.ReadCloser, error) {
	ret := _m.Called(ctx, initramfs)

	if len(ret) == 0 {
		panic("no return value specified for EncodeLinuxInitramfs")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader) (io.ReadCloser, error)); ok {
		return rf(ctx, initramfs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader) io.ReadCloser); ok {
		r0 = rf(ctx, initramfs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, io.Reader) error); ok {
		r1 = rf(ctx, initramfs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockHypervisor_EncodeLinuxInitramfs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeLinuxInitramfs'
type MockHypervisor_EncodeLinuxInitramfs_Call[VM vmm.VirtualMachine] struct {
	*mock.Call
}

// EncodeLinuxInitramfs is a helper method to define mock.On call
//   - ctx context.Context
//   - initramfs io.Reader
func (_e *MockHypervisor_Expecter[VM]) EncodeLinuxInitramfs(ctx interface{}, initramfs interface{}) *MockHypervisor_EncodeLinuxInitramfs_Call[VM] {
	return &MockHypervisor_EncodeLinuxInitramfs_Call[VM]{Call: _e.mock.On("EncodeLinuxInitramfs", ctx, initramfs)}
}

func (_c *MockHypervisor_EncodeLinuxInitramfs_Call[VM]) Run(run func(ctx context.Context, initramfs io.Reader)) *MockHypervisor_EncodeLinuxInitramfs_Call[VM] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(io.Reader))
	})
	return _c
}

func (_c *MockHypervisor_EncodeLinuxInitramfs_Call[VM]) Return(_a0 io.ReadCloser, _a1 error) *MockHypervisor_EncodeLinuxInitramfs_Call[VM] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockHypervisor_EncodeLinuxInitramfs_Call[VM]) RunAndReturn(run func(context.Context, io.Reader) (io.ReadCloser, error)) *MockHypervisor_EncodeLinuxInitramfs_Call[VM] {
	_c.Call.Return(run)
	return _c
}

// EncodeLinuxKernel provides a mock function with given fields: ctx, kernel
func (_m *MockHypervisor[VM]) EncodeLinuxKernel(ctx context.Context, kernel io.Reader) (io.ReadCloser, error) {
	ret := _m.Called(ctx, kernel)

	if len(ret) == 0 {
		panic("no return value specified for EncodeLinuxKernel")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader) (io.ReadCloser, error)); ok {
		return rf(ctx, kernel)
	}
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader) io.ReadCloser); ok {
		r0 = rf(ctx, kernel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, io.Reader) error); ok {
		r1 = rf(ctx, kernel)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockHypervisor_EncodeLinuxKernel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeLinuxKernel'
type MockHypervisor_EncodeLinuxKernel_Call[VM vmm.VirtualMachine] struct {
	*mock.Call
}

// EncodeLinuxKernel is a helper method to define mock.On call
//   - ctx context.Context
//   - kernel io.Reader
func (_e *MockHypervisor_Expecter[VM]) EncodeLinuxKernel(ctx interface{}, kernel interface{}) *MockHypervisor_EncodeLinuxKernel_Call[VM] {
	return &MockHypervisor_EncodeLinuxKernel_Call[VM]{Call: _e.mock.On("EncodeLinuxKernel", ctx, kernel)}
}

func (_c *MockHypervisor_EncodeLinuxKernel_Call[VM]) Run(run func(ctx context.Context, kernel io.Reader)) *MockHypervisor_EncodeLinuxKernel_Call[VM] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(io.Reader))
	})
	return _c
}

func (_c *MockHypervisor_EncodeLinuxKernel_Call[VM]) Return(_a0 io.ReadCloser, _a1 error) *MockHypervisor_EncodeLinuxKernel_Call[VM] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockHypervisor_EncodeLinuxKernel_Call[VM]) RunAndReturn(run func(context.Context, io.Reader) (io.ReadCloser, error)) *MockHypervisor_EncodeLinuxKernel_Call[VM] {
	_c.Call.Return(run)
	return _c
}

// EncodeLinuxRootfs provides a mock function with given fields: ctx, rootfs
func (_m *MockHypervisor[VM]) EncodeLinuxRootfs(ctx context.Context, rootfs io.Reader) (io.ReadCloser, error) {
	ret := _m.Called(ctx, rootfs)

	if len(ret) == 0 {
		panic("no return value specified for EncodeLinuxRootfs")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader) (io.ReadCloser, error)); ok {
		return rf(ctx, rootfs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader) io.ReadCloser); ok {
		r0 = rf(ctx, rootfs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, io.Reader) error); ok {
		r1 = rf(ctx, rootfs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockHypervisor_EncodeLinuxRootfs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeLinuxRootfs'
type MockHypervisor_EncodeLinuxRootfs_Call[VM vmm.VirtualMachine] struct {
	*mock.Call
}

// EncodeLinuxRootfs is a helper method to define mock.On call
//   - ctx context.Context
//   - rootfs io.Reader
func (_e *MockHypervisor_Expecter[VM]) EncodeLinuxRootfs(ctx interface{}, rootfs interface{}) *MockHypervisor_EncodeLinuxRootfs_Call[VM] {
	return &MockHypervisor_EncodeLinuxRootfs_Call[VM]{Call: _e.mock.On("EncodeLinuxRootfs", ctx, rootfs)}
}

func (_c *MockHypervisor_EncodeLinuxRootfs_Call[VM]) Run(run func(ctx context.Context, rootfs io.Reader)) *MockHypervisor_EncodeLinuxRootfs_Call[VM] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(io.Reader))
	})
	return _c
}

func (_c *MockHypervisor_EncodeLinuxRootfs_Call[VM]) Return(_a0 io.ReadCloser, _a1 error) *MockHypervisor_EncodeLinuxRootfs_Call[VM] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockHypervisor_EncodeLinuxRootfs_Call[VM]) RunAndReturn(run func(context.Context, io.Reader) (io.ReadCloser, error)) *MockHypervisor_EncodeLinuxRootfs_Call[VM] {
	_c.Call.Return(run)
	return _c
}

// InitramfsCompression provides a mock function with no fields
func (_m *MockHypervisor[VM]) InitramfsCompression() archives.Compression {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InitramfsCompression")
	}

	var r0 archives.Compression
	if rf, ok := ret.Get(0).(func() archives.Compression); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(archives.Compression)
		}
	}

	return r0
}

// MockHypervisor_InitramfsCompression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitramfsCompression'
type MockHypervisor_InitramfsCompression_Call[VM vmm.VirtualMachine] struct {
	*mock.Call
}

// InitramfsCompression is a helper method to define mock.On call
func (_e *MockHypervisor_Expecter[VM]) InitramfsCompression() *MockHypervisor_InitramfsCompression_Call[VM] {
	return &MockHypervisor_InitramfsCompression_Call[VM]{Call: _e.mock.On("InitramfsCompression")}
}

func (_c *MockHypervisor_InitramfsCompression_Call[VM]) Run(run func()) *MockHypervisor_InitramfsCompression_Call[VM] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockHypervisor_InitramfsCompression_Call[VM]) Return(_a0 archives.Compression) *MockHypervisor_InitramfsCompression_Call[VM] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHypervisor_InitramfsCompression_Call[VM]) RunAndReturn(run func() archives.Compression) *MockHypervisor_InitramfsCompression_Call[VM] {
	_c.Call.Return(run)
	return _c
}

// NewVirtualMachine provides a mock function with given fields: ctx, id, opts, bl
func (_m *MockHypervisor[VM]) NewVirtualMachine(ctx context.Context, id string, opts *vmm.NewVMOptions, bl vmm.Bootloader) (VM, error) {
	ret := _m.Called(ctx, id, opts, bl)

	if len(ret) == 0 {
		panic("no return value specified for NewVirtualMachine")
	}

	var r0 VM
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *vmm.NewVMOptions, vmm.Bootloader) (VM, error)); ok {
		return rf(ctx, id, opts, bl)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *vmm.NewVMOptions, vmm.Bootloader) VM); ok {
		r0 = rf(ctx, id, opts, bl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(VM)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *vmm.NewVMOptions, vmm.Bootloader) error); ok {
		r1 = rf(ctx, id, opts, bl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockHypervisor_NewVirtualMachine_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewVirtualMachine'
type MockHypervisor_NewVirtualMachine_Call[VM vmm.VirtualMachine] struct {
	*mock.Call
}

// NewVirtualMachine is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - opts *vmm.NewVMOptions
//   - bl vmm.Bootloader
func (_e *MockHypervisor_Expecter[VM]) NewVirtualMachine(ctx interface{}, id interface{}, opts interface{}, bl interface{}) *MockHypervisor_NewVirtualMachine_Call[VM] {
	return &MockHypervisor_NewVirtualMachine_Call[VM]{Call: _e.mock.On("NewVirtualMachine", ctx, id, opts, bl)}
}

func (_c *MockHypervisor_NewVirtualMachine_Call[VM]) Run(run func(ctx context.Context, id string, opts *vmm.NewVMOptions, bl vmm.Bootloader)) *MockHypervisor_NewVirtualMachine_Call[VM] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*vmm.NewVMOptions), args[3].(vmm.Bootloader))
	})
	return _c
}

func (_c *MockHypervisor_NewVirtualMachine_Call[VM]) Return(_a0 VM, _a1 error) *MockHypervisor_NewVirtualMachine_Call[VM] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockHypervisor_NewVirtualMachine_Call[VM]) RunAndReturn(run func(context.Context, string, *vmm.NewVMOptions, vmm.Bootloader) (VM, error)) *MockHypervisor_NewVirtualMachine_Call[VM] {
	_c.Call.Return(run)
	return _c
}

// OnCreate provides a mock function with no fields
func (_m *MockHypervisor[VM]) OnCreate() <-chan VM {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for OnCreate")
	}

	var r0 <-chan VM
	if rf, ok := ret.Get(0).(func() <-chan VM); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan VM)
		}
	}

	return r0
}

// MockHypervisor_OnCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnCreate'
type MockHypervisor_OnCreate_Call[VM vmm.VirtualMachine] struct {
	*mock.Call
}

// OnCreate is a helper method to define mock.On call
func (_e *MockHypervisor_Expecter[VM]) OnCreate() *MockHypervisor_OnCreate_Call[VM] {
	return &MockHypervisor_OnCreate_Call[VM]{Call: _e.mock.On("OnCreate")}
}

func (_c *MockHypervisor_OnCreate_Call[VM]) Run(run func()) *MockHypervisor_OnCreate_Call[VM] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockHypervisor_OnCreate_Call[VM]) Return(_a0 <-chan VM) *MockHypervisor_OnCreate_Call[VM] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHypervisor_OnCreate_Call[VM]) RunAndReturn(run func() <-chan VM) *MockHypervisor_OnCreate_Call[VM] {
	_c.Call.Return(run)
	return _c
}

// NewMockHypervisor creates a new instance of MockHypervisor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHypervisor[VM vmm.VirtualMachine](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockHypervisor[VM] {
	mock := &MockHypervisor[VM]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
